{ "info": { "description": "A simple service to ingest a KML or ShapeFile into a PostGIS capable PostgreSQL database and publish an associated layer to GeoServer.", "contact": { "email": "pmitropoulos@getmap.gr" }, "title": "Ingest/Publish API", "version": null }, "externalDocs": { "description": "GitHub", "url": "https://github.com/OpertusMundi/ingest" }, "paths": { "/ingest": { "post": { "summary": "Ingest a vector file (Shapefile/KML) into PostGIS.", "tags": [ "Ingest" ], "parameters": [ { "in": "header", "name": "X-Idempotency-Key", "description": "Associates the request with an Idempotency Key (it has to be unique).", "schema": { "type": "string", "format": "uuid" }, "required": false } ], "requestBody": { "required": true, "content": { "multipart/form-data": { "schema": { "type": "object", "properties": { "resource": { "type": "string", "format": "binary", "description": "The vector file." }, "response": { "type": "string", "enum": [ "prompt", "deferred" ], "default": "prompt", "description": "Determines whether the proccess should be promptly initiated (*prompt*) or queued (*deferred*). In the first case, the response waits for the result, in the second the response is immediate returning a ticket corresponding to the request." }, "tablename": { "type": "string", "description": "The name of the table into which the data will be ingested (it should be a new table). By default, a unique random name will be given to the new table." }, "schema": { "type": "string", "description": "The schema in which the table will be created (it has to exist). If not given, the default schema will be used." }, "replace": { "type": "boolean", "description": "If true, the table will be replace if exists.", "default": false } }, "required": [ "resource" ] } }, "application/x-www-form-urlencoded": { "schema": { "type": "object", "properties": { "resource": { "type": "string", "description": "The vector file resolvable path." }, "response": { "type": "string", "enum": [ "prompt", "deferred" ], "default": "prompt", "description": "Determines whether the proccess should be promptly initiated (*prompt*) or queued (*deferred*). In the first case, the response waits for the result, in the second the response is immediate returning a ticket corresponding to the request." }, "tablename": { "type": "string", "description": "The name of the table into which the data will be ingested (it should be a new table). By default, a unique random name will be given to a new table." }, "schema": { "type": "string", "description": "The schema in which the table will be created (schema has to exist). If not given, the default schema will be used." }, "replace": { "type": "boolean", "description": "If true, the table will be replace if exists.", "default": false } }, "required": [ "resource" ] } } } }, "responses": { "200": { "description": "Ingestion / publication completed.", "content": { "application/json": { "schema": { "type": "object", "properties": { "schema": { "type": "string", "description": "The schema of the created table." }, "table": { "type": "string", "description": "The name of the created table." }, "length": { "type": "integer", "description": "The number of features stored in the table." }, "type": { "type": "string", "description": "The response type as requested." } } } } } }, "202": { "description": "Accepted for processing, but ingestion/publish has not been completed.", "content": { "application/json": { "schema": { "type": "object", "properties": { "ticket": { "type": "string", "description": "The ticket corresponding to the request." }, "status": { "type": "string", "description": "The *status* endpoint to poll for the status of the request." }, "type": { "type": "string", "description": "The response type as requested." } } } } }, "links": { "GetStatus": { "operationId": "getStatus", "parameters": { "ticket": "$response.body#/ticket" }, "description": "The `ticket` value returned in the response can be used as the `ticket` parameter in `GET /status/{ticket}`." } } }, "400": { "description": "General client error or database schema does not exist." }, "403": { "description": "Insufficient privilege for writing in the database schema." } } } }, "/publish": { "post": { "summary": "Publishes a layer to GeoServer from PostGIS table.", "tags": [ "Publish" ], "parameters": [ { "in": "header", "name": "X-Idempotency-Key", "schema": { "type": "string", "format": "uuid" }, "required": false } ], "requestBody": { "required": true, "content": { "application/x-www-form-urlencoded": { "schema": { "type": "object", "properties": { "table": { "type": "string", "description": "The table name." }, "schema": { "type": "string", "description": "The database schema in which the table exists." }, "workspace": { "type": "string", "description": "The GeoServer workspace in which the layer will be published (it will be created if does not exist). If not given, the default workspace will be used." } }, "required": [ "table" ] } } } }, "responses": { "200": { "description": "Publication completed.", "content": { "application/json": { "schema": { "type": "object", "properties": { "wms": { "type": "string", "description": "WMS endpoint" }, "wfs": { "type": "string", "description": "WFS endpoint" } } } } } }, "400": { "description": "General client error or table does not exist." } } } }, "/status/{ticket}": { "get": { "summary": "Get the status of a request.", "operationId": "getStatus", "description": "Returns the status of a request corresponding to a specific ticket.", "tags": [ "Status" ], "parameters": [ { "name": "ticket", "in": "path", "description": "The ticket of the request", "required": true, "schema": { "type": "string" } } ], "responses": { "200": { "description": "Ticket found and status returned.", "content": { "application/json": { "schema": { "type": "object", "properties": { "completed": { "type": "boolean", "description": "Whether ingestion/publication process has been completed or not." }, "success": { "type": "boolean", "description": "Whether the process completed succesfully." }, "comment": { "type": "string", "description": "If ingestion/publication has failed, a short comment describing the reason." }, "requested": { "type": "string", "format": "datetime", "description": "The timestamp of the request." }, "executionTime": { "type": "integer", "description": "The execution time in seconds." } } } } } }, "404": { "description": "Ticket not found." } } } }, "/result/{ticket}": { "get": { "summary": "Get the result of the ingest.", "description": "Returns the table in PostGIS resulted from a ingestion request corresponding to a specific ticket.", "tags": [ "Result" ], "parameters": [ { "name": "ticket", "in": "path", "description": "The ticket of the request", "required": true, "schema": { "type": "string" } } ], "responses": { "200": { "description": "The resulted endpoints.", "content": { "application/json": { "schema": { "type": "object", "properties": { "schema": { "type": "string", "description": "The schema of the created table." }, "table": { "type": "string", "description": "The name of the created table." }, "length": { "type": "integer", "description": "The number of features stored in the table." } } } } } }, "404": { "description": "Ticket not found or ingest has not been completed." } } } }, "/_health": { "get": { "tags": [ "Health" ], "summary": "Get health status", "description": "Get health status", "operationId": "getHealth", "responses": { "default": { "description": "An object with status information", "content": { "application/json": { "schema": { "type": "object", "properties": { "status": { "type": "string", "description": "A status of 'OK' or 'FAILED'" }, "reason": { "type": "string", "description": "the reason of failure (if failed)" }, "detail": { "type": "string", "description": "more details on this failure (if failed)" } } }, "examples": { "example-1": { "status": "OK" } } } } } } } }, "/ticket_by_key/{key}": { "get": { "summary": "Returns a request ticket associated with an idempotent key.", "tags": [ "Ticket" ], "parameters": [ { "name": "key", "in": "path", "description": "The idempotent key as sent in X-Idempotency-Key header.", "required": true, "schema": { "type": "string" } } ], "responses": { "200": { "description": "The associated request and ticket.", "content": { "application/json": { "schema": { "type": "object", "properties": { "ticket": { "type": "string", "description": "The associated ticket." }, "request": { "type": "string", "enum": [ "ingest", "publish" ], "description": "The request of this ticket." } } } } } }, "404": { "description": "Idempotent key not found." } } } }, "/ingest/{table}": { "delete": { "summary": "Remove all ingested data relative to the given table.", "description": "Unpublishes the corresponding layer from GeoServer and drops the database table.", "tags": [ "Ingest" ], "parameters": [ { "name": "schema", "in": "path", "description": "The database schema; if not present the default schema will be assumed.", "required": true, "schema": { "type": "string" } }, { "name": "workspace", "in": "path", "description": "The workspace that the layer belongs; if not present, the default workspace will be assumed.", "required": true, "schema": { "type": "string" } } ], "responses": { "204": { "description": "Table dropped (if existed)." } } } }, "/publish/{layer}": { "delete": { "summary": "Unpublish a GeoServer layer.", "description": "Removes both the layer and feature type from GeoServer.", "tags": [ "Publish" ], "parameters": [ { "name": "workspace", "in": "path", "description": "The workspace that the layer belongs; if not present, the default workspace will be assumed.", "required": true, "schema": { "type": "string" } } ], "responses": { "204": { "description": "Layer unpulished (if existed)." } } } } }, "openapi": "3.0.2" }